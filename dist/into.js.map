{"version":3,"file":"into.js","sources":["../src/internal/combine.js","../src/into.js"],"sourcesContent":["export const combine = {\n  push: (state = [], value) => (state.push(value), state),\n  add: (state, value) => state.add(value),\n  force: (state, value) => value,\n  set: (state, [key, value]) => state.set(key, value),\n  concat: (state, value) => state.concat(value),\n  merge: (state, [key, value]) => {\n    state[key] = value;\n\n    return state;\n  },\n};\n","import { combine } from '#utils/internal/combine.js';\nimport { transduce } from '#utils/transduce.js';\n\n/**\n * @typedef  {Object} Into\n * @property {function(Function,Collection): Array}  [array]   - Function: (value, index, collection, accumulator) => any, Merge strategy: Array.push\n * @property {function(Function,Collection): string} [string]  - Function: (value, index, collection, accumulator) => any, Merge strategy: concatenation\n * @property {function(Function,Collection): number} [number]  - Function: (value, index, collection, accumulator) => any, Merge strategy: last returned value becomes the accumulator\n * @property {function(Function,Collection): Set}    [set]     - Function: (value, index, collection, accumulator) => any, Merge strategy: Set.add\n * @property {function(Function,Collection): Map}    [map]     - Function: ([key, value], index, collection, accumulator) => [any, any], Merge strategy: Map.add\n * @property {function(Function,Collection): Object} [object]  - Function: ([key, value], index, collection, accumulator) => [any, any], Merge strategy: object assignation\n * @preserve true\n */\n\n/**\n * @description\n * Transforms the items of the iterable with the transducer and appends the transformed items to\n * the accumulator using an appropriate iterator function based on the accumulator type.\n *\n * The transducer function takes 4 params: (value, index, collection, accumulator). Then value\n * parameter is a pair [key, value] when the accumulator is an Object or a Map.\n *\n * In the case the accumulator is a number (into.number), there is no merge strategy and just\n * returns what the transducer returns\n *\n * The iteration is performed with reduce after initializing the transducer.\n *\n * @type {Into}\n * @category Transformation\n * @example\n * var value = ([k, v]] => v\n * var isEven = (x) => x % 2 === 0\n * var isVowel = (x) => /aeiou/.test(x)\n * var isObject = (x) => typeof x === 'object'\n * var toUppercase = (x) => x.toUppercase()\n * var addAccumulator = (value, index, collection, accumulator) => value + accumulator\n * var pairById = (x) => [x.id, x]\n *\n * into.array(compose(map(value), filter(isEven)), {a: 1, b: 2}) // [2]\n *\n * into.string(compose(filter(isVowel), map(toUppercase)), 'string') // 'I'\n *\n * into.number(map(addAccumulator), [1, 2, 3]) // 1 + 2 + 3 = 6\n *\n * into.object(\n *   compose(filter(isObject), map(pairById)),\n *     [1, { id: '1-2-3', value: 10 }]\n *   ) // { '1-2-3': { id: '1-2-3', value: 10 } }\n *\n * @preserve true\n */\nexport const into = {\n  array: function (transducer, collection) {\n    if (arguments.length === 1)\n      return (_collection) => into.array(transducer, _collection);\n\n    return transduce(transducer, combine.push, [], collection);\n  },\n  string: function (transducer, collection) {\n    if (arguments.length === 1)\n      return (_collection) => into.string(transducer, _collection);\n\n    return transduce(transducer, combine.concat, '', collection);\n  },\n  number: function (transducer, collection) {\n    if (arguments.length === 1)\n      return (_collection) => into.number(transducer, _collection);\n\n    return transduce(transducer, combine.force, 0, collection);\n  },\n  set: function (transducer, collection) {\n    if (arguments.length === 1)\n      return (_collection) => into.set(transducer, _collection);\n\n    return transduce(transducer, combine.add, new Set(), collection);\n  },\n  map: function (transducer, collection) {\n    if (arguments.length === 1)\n      return (_collection) => into.map(transducer, _collection);\n\n    return transduce(transducer, combine.set, new Map(), collection);\n  },\n  object: function (transducer, collection) {\n    if (arguments.length === 1)\n      return (_collection) => into.object(transducer, _collection);\n\n    return transduce(transducer, combine.merge, {}, collection);\n  },\n};\n"],"names":[],"mappings":";;;;;;;AAAO,MAAM,UAAU;AAAA,EACrB,MAAM,CAAC,QAAQ,IAAI,WAAW,MAAM,KAAK,KAAK,GAAG;AAAA,EACjD,KAAK,CAAC,OAAO,UAAU,MAAM,IAAI,KAAK;AAAA,EACtC,OAAO,CAAC,OAAO,UAAU;AAAA,EACzB,KAAK,CAAC,OAAO,CAAC,KAAK,KAAK,MAAM,MAAM,IAAI,KAAK,KAAK;AAAA,EAClD,QAAQ,CAAC,OAAO,UAAU,MAAM,OAAO,KAAK;AAAA,EAC5C,OAAO,CAAC,OAAO,CAAC,KAAK,KAAK,MAAM;AAC9B,UAAM,GAAG,IAAI;AAEb,WAAO;AAAA,EACR;AACH;ACRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqCY,MAAC,OAAO;AAAA,EAClB,OAAO,SAAU,YAAY,YAAY;AACvC,QAAI,UAAU,WAAW;AACvB,aAAO,CAAC,gBAAgB,KAAK,MAAM,YAAY,WAAW;AAE5D,WAAO,UAAU,YAAY,QAAQ,MAAM,CAAA,GAAI,UAAU;AAAA,EAC1D;AAAA,EACD,QAAQ,SAAU,YAAY,YAAY;AACxC,QAAI,UAAU,WAAW;AACvB,aAAO,CAAC,gBAAgB,KAAK,OAAO,YAAY,WAAW;AAE7D,WAAO,UAAU,YAAY,QAAQ,QAAQ,IAAI,UAAU;AAAA,EAC5D;AAAA,EACD,QAAQ,SAAU,YAAY,YAAY;AACxC,QAAI,UAAU,WAAW;AACvB,aAAO,CAAC,gBAAgB,KAAK,OAAO,YAAY,WAAW;AAE7D,WAAO,UAAU,YAAY,QAAQ,OAAO,GAAG,UAAU;AAAA,EAC1D;AAAA,EACD,KAAK,SAAU,YAAY,YAAY;AACrC,QAAI,UAAU,WAAW;AACvB,aAAO,CAAC,gBAAgB,KAAK,IAAI,YAAY,WAAW;AAE1D,WAAO,UAAU,YAAY,QAAQ,KAAK,oBAAI,IAAG,GAAI,UAAU;AAAA,EAChE;AAAA,EACD,KAAK,SAAU,YAAY,YAAY;AACrC,QAAI,UAAU,WAAW;AACvB,aAAO,CAAC,gBAAgB,KAAK,IAAI,YAAY,WAAW;AAE1D,WAAO,UAAU,YAAY,QAAQ,KAAK,oBAAI,IAAG,GAAI,UAAU;AAAA,EAChE;AAAA,EACD,QAAQ,SAAU,YAAY,YAAY;AACxC,QAAI,UAAU,WAAW;AACvB,aAAO,CAAC,gBAAgB,KAAK,OAAO,YAAY,WAAW;AAE7D,WAAO,UAAU,YAAY,QAAQ,OAAO,CAAA,GAAI,UAAU;AAAA,EAC3D;AACH;"}